{
  "version": 3,
  "sources": ["../../@jridgewell/set-array/src/set-array.ts", "../../@jridgewell/sourcemap-codec/src/vlq.ts", "../../@jridgewell/sourcemap-codec/src/strings.ts", "../../@jridgewell/sourcemap-codec/src/scopes.ts", "../../@jridgewell/sourcemap-codec/src/sourcemap-codec.ts", "../../@jridgewell/resolve-uri/src/resolve-uri.ts", "../../@jridgewell/trace-mapping/src/resolve.ts", "../../@jridgewell/trace-mapping/src/strip-filename.ts", "../../@jridgewell/trace-mapping/src/sourcemap-segment.ts", "../../@jridgewell/trace-mapping/src/sort.ts", "../../@jridgewell/trace-mapping/src/binary-search.ts", "../../@jridgewell/trace-mapping/src/by-source.ts", "../../@jridgewell/trace-mapping/src/any-map.ts", "../../@jridgewell/trace-mapping/src/trace-mapping.ts", "../../@jridgewell/gen-mapping/src/sourcemap-segment.ts", "../../@jridgewell/gen-mapping/src/gen-mapping.ts", "../../@babel/generator/src/source-map.ts", "../../@babel/generator/src/buffer.ts", "../../@babel/generator/src/node/whitespace.ts", "../../@babel/generator/src/node/parentheses.ts", "../../@babel/generator/src/node/index.ts", "../../@babel/generator/src/token-map.ts", "../../@babel/generator/src/generators/template-literals.ts", "../../@babel/generator/src/generators/expressions.ts", "../../@babel/generator/src/generators/statements.ts", "../../@babel/generator/src/generators/classes.ts", "../../@babel/generator/src/generators/methods.ts", "../../@babel/generator/src/generators/modules.ts", "../../jsesc/jsesc.js", "../../@babel/generator/src/generators/types.ts", "../../@babel/generator/src/generators/flow.ts", "../../@babel/generator/src/generators/base.ts", "../../@babel/generator/src/generators/jsx.ts", "../../@babel/generator/src/generators/typescript.ts", "../../@babel/generator/src/generators/index.ts", "../../@babel/generator/src/generators/deprecated.ts", "../../@babel/generator/src/printer.ts", "../../@babel/generator/src/index.ts"],
  "sourcesContent": ["type Key = string | number | symbol;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray<T extends Key = Key> {\n  private declare _indexes: Record<T, number | undefined>;\n  declare array: readonly T[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n}\n\ninterface PublicSet<T extends Key> {\n  array: T[];\n  _indexes: SetArray<T>['_indexes'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast<T extends Key>(set: SetArray<T>): PublicSet<T> {\n  return set as any;\n}\n\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport function get<T extends Key>(setarr: SetArray<T>, key: T): number | undefined {\n  return cast(setarr)._indexes[key];\n}\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport function put<T extends Key>(setarr: SetArray<T>, key: T): number {\n  // The key may or may not be present. If it is present, it's a number.\n  const index = get(setarr, key);\n  if (index !== undefined) return index;\n\n  const { array, _indexes: indexes } = cast(setarr);\n\n  const length = array.push(key);\n  return (indexes[key] = length - 1);\n}\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport function pop<T extends Key>(setarr: SetArray<T>): void {\n  const { array, _indexes: indexes } = cast(setarr);\n  if (array.length === 0) return;\n\n  const last = array.pop()!;\n  indexes[last] = undefined;\n}\n\n/**\n * Removes the key, if it exists in the set.\n */\nexport function remove<T extends Key>(setarr: SetArray<T>, key: T): void {\n  const index = get(setarr, key);\n  if (index === undefined) return;\n\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]!--;\n  }\n  indexes[key] = undefined;\n  array.pop();\n}\n", "import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n", "const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array): string {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array): string {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  private declare buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n", "import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n", "import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n", "// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n", "import resolveUri from '@jridgewell/resolve-uri';\n\nexport default function resolve(input: string, base: string | undefined): string {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n\n  return resolveUri(input, base);\n}\n", "/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n", "type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n", "import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n", "import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n", "import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      let index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n", "import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type {\n  DecodedSourceMap,\n  DecodedSourceMapXInput,\n  EncodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionedSourceMapInput,\n  SectionXInput,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype AnyMap = {\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\n\nexport const AnyMap: AnyMap = function (map, mapUrl) {\n  const parsed = parse(map);\n\n  if (!('sections' in parsed)) {\n    return new TraceMap(parsed as DecodedSourceMapXInput | EncodedSourceMapXInput, mapUrl);\n  }\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n  const ignoreList: number[] = [];\n\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity,\n  );\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList,\n  };\n\n  return presortedDecodedMap(joined);\n} as AnyMap;\n\nfunction parse<T>(map: T): Exclude<T, string> {\n  return typeof map === 'string' ? JSON.parse(map) : map;\n}\n\nfunction recurse(\n  input: SectionedSourceMapXInput,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: SectionXInput['map'],\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  ignoreList: number[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const parsed = parse(input);\n  if ('sections' in parsed) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n", "import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolve from './resolve';\nimport stripFilename from './strip-filename';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n  XInput,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMap,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  Section,\n  SectionedSourceMap,\n  SourceMapV3,\n  Bias,\n  EachMapping,\n  GeneratedMapping,\n  InvalidGeneratedMapping,\n  InvalidOriginalMapping,\n  Needle,\n  OriginalMapping,\n  OriginalMapping as Mapping,\n  SectionedSourceMapInput,\n  SourceMapInput,\n  SourceNeedle,\n  XInput,\n  EncodedSourceMapXInput,\n  DecodedSourceMapXInput,\n  SectionedSourceMapXInput,\n  SectionXInput,\n} from './types';\n\ninterface PublicMap {\n  _encoded: TraceMap['_encoded'];\n  _decoded: TraceMap['_decoded'];\n  _decodedMemo: TraceMap['_decodedMemo'];\n  _bySources: TraceMap['_bySources'];\n  _bySourceMemos: TraceMap['_bySourceMemos'];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\nexport { AnyMap } from './any-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n  declare ignoreList: SourceMapV3['ignoreList'];\n\n  declare resolvedSources: string[];\n  private declare _encoded: string | undefined;\n\n  private declare _decoded: SourceMapSegment[][] | undefined;\n  private declare _decodedMemo: MemoState;\n\n  private declare _bySources: Source[] | undefined;\n  private declare _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || (parsed as XInput).x_google_ignoreList || undefined;\n\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport function encodedMappings(map: TraceMap): EncodedSourceMap['mappings'] {\n  return (cast(map)._encoded ??= encode(cast(map)._decoded!));\n}\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport function decodedMappings(map: TraceMap): Readonly<DecodedSourceMap['mappings']> {\n  return (cast(map)._decoded ||= decode(cast(map)._encoded!));\n}\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport function traceSegment(\n  map: TraceMap,\n  line: number,\n  column: number,\n): Readonly<SourceMapSegment> | null {\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return null;\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND,\n  );\n\n  return index === -1 ? null : segments[index];\n}\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport function originalPositionFor(\n  map: TraceMap,\n  needle: Needle,\n): OriginalMapping | InvalidOriginalMapping {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const decoded = decodedMappings(map);\n\n  // It's common for parent source maps to have pointers to lines that have no\n  // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND,\n  );\n\n  if (index === -1) return OMapping(null, null, null, null);\n\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n  );\n}\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport function generatedPositionFor(\n  map: TraceMap,\n  needle: SourceNeedle,\n): GeneratedMapping | InvalidGeneratedMapping {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport function allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle): GeneratedMapping[] {\n  const { source, line, column, bias } = needle;\n  // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport function eachMapping(map: TraceMap, cb: (mapping: EachMapping) => void): void {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name,\n      } as EachMapping);\n    }\n  }\n}\n\nfunction sourceIndex(map: TraceMap, source: string): number {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport function sourceContentFor(map: TraceMap, source: string): string | null {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\n\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nexport function isIgnored(map: TraceMap, source: string): boolean {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport function presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string): TraceMap {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function decodedMap(\n  map: TraceMap,\n): Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] } {\n  return clone(map, decodedMappings(map));\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function encodedMap(map: TraceMap): EncodedSourceMap {\n  return clone(map, encodedMappings(map));\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || (map as XInput).x_google_ignoreList,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: false,\n): GeneratedMapping | InvalidGeneratedMapping;\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: true,\n): GeneratedMapping[];\nfunction generatedPosition(\n  map: TraceMap,\n  source: string,\n  line: number,\n  column: number,\n  bias: Bias,\n  all: boolean,\n): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n  const { sources, resolvedSources } = map;\n  let sourceIndex = sources.indexOf(source);\n  if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n  if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n  const generated = (cast(map)._bySources ||= buildBySources(\n    decodedMappings(map),\n    (cast(map)._bySourceMemos = sources.map(memoizedState)),\n  ));\n\n  const segments = generated[sourceIndex][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n\n  const memo = cast(map)._bySourceMemos![sourceIndex];\n\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n", "type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n", "import { SetArray, put, remove } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private declare _names: SetArray<string>;\n  private declare _sources: SetArray<string>;\n  private declare _sourcesContent: (string | null)[];\n  private declare _mappings: SourceMapSegment[][];\n  private declare _ignoreList: SetArray<number>;\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n}\n\ninterface PublicMap {\n  _names: GenMapping['_names'];\n  _sources: GenMapping['_sources'];\n  _sourcesContent: GenMapping['_sourcesContent'];\n  _mappings: GenMapping['_mappings'];\n  _ignoreList: GenMapping['_ignoreList'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: null,\n  sourceLine?: null,\n  sourceColumn?: null,\n  name?: null,\n  content?: null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name?: null,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name: string,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: string | null,\n  sourceLine?: number | null,\n  sourceColumn?: number | null,\n  name?: string | null,\n  content?: string | null,\n): void {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n}\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: null;\n    original?: null;\n    name?: null;\n    content?: null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name?: null;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name: string;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: string | null;\n    original?: Pos | null;\n    name?: string | null;\n    content?: string | null;\n  },\n): void {\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n}\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport const maybeAddSegment: typeof addSegment = (\n  map,\n  genLine,\n  genColumn,\n  source,\n  sourceLine,\n  sourceColumn,\n  name,\n  content,\n) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n};\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\n  const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\n\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\n  const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList,\n  } = cast(map);\n  removeEmptyFinalLines(mappings);\n\n  return {\n    version: 3,\n    file: map.file || undefined,\n    names: names.array,\n    sourceRoot: map.sourceRoot || undefined,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    ignoreList: ignoreList.array,\n  };\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\n  const decoded = toDecodedMap(map);\n  return {\n    ...decoded,\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\n  };\n}\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport function fromMap(input: SourceMapInput): GenMapping {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n  putAll(cast(gen)._names, map.names);\n  putAll(cast(gen)._sources, map.sources as string[]);\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n\n  return gen;\n}\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport function allMappings(map: GenMapping): Mapping[] {\n  const out: Mapping[] = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source: string | undefined = undefined;\n      let original: Pos | undefined = undefined;\n      let name: string | undefined = undefined;\n\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n\n      out.push({ generated, source, original, name } as Mapping);\n    }\n  }\n\n  return out;\n}\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n): void {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n  } = cast(map);\n  const line = getLine(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n  // isn't nullish.\n  assert<number>(sourceLine);\n  assert<number>(sourceColumn);\n\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n\n  return insert(\n    line,\n    index,\n    name\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n  );\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source as string,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n", "import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport {\n  type SourceMapInput,\n  originalPositionFor,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we only check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | { [sourceFileName: string]: string },\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code[sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line: number,\n    column: number,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: {\n      source: string | null;\n      name?: string | null;\n      line: number | null;\n      column: number | null;\n    };\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName,\n          line: line,\n          column: column,\n        };\n      }\n    }\n\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n", "import type SourceMap from \"./source-map.ts\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n  index: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _fastIndentations: string[] = [];\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(repeat: number): void {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str +=\n          repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   */\n  endsWithCharAndNewline(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n", "import {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral,\n} from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nimport type { NodeHandlers } from \"./index.ts\";\n\nimport type * as t from \"@babel/types\";\n\nconst enum WhitespaceFlag {\n  before = 1 << 0,\n  after = 1 << 1,\n}\n\nexport type { WhitespaceFlag };\n\nfunction crawlInternal(\n  node: t.Node,\n  state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },\n) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper =\n      // @ts-expect-error todo(flow->ts): node.callee is not really expected here…\n      state.hasHelper || (node.callee && isHelper(node.callee));\n  }\n\n  return state;\n}\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node: t.Node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false,\n  });\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node: t.Node): boolean {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return (\n      node.name === \"require\" ||\n      node.name.charCodeAt(0) === charCodes.underscore\n    );\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return (\n      (isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)\n    );\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node: t.Node) {\n  return (\n    isLiteral(node) ||\n    isObjectExpression(node) ||\n    isArrayExpression(node) ||\n    isIdentifier(node) ||\n    isMemberExpression(node)\n  );\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexport const nodes: NodeHandlers<WhitespaceFlag> = {\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {\n    const state = crawl(node.right);\n    if ((state.hasCall && state.hasHelper) || state.hasFunction) {\n      return state.hasFunction\n        ? WhitespaceFlag.before | WhitespaceFlag.after\n        : WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {\n    return (\n      (!!node.consequent.length || parent.cases[0] === node\n        ? WhitespaceFlag.before\n        : 0) |\n      (!node.consequent.length && parent.cases[parent.cases.length - 1] === node\n        ? WhitespaceFlag.after\n        : 0)\n    );\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal(node: t.Literal): WhitespaceFlag {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if CallExpressionish needs whitespace.\n   */\n\n  CallExpression(node: t.CallExpression): WhitespaceFlag {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {\n    if (isFunction(node.callee)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;\n      }\n\n      if (enabled) {\n        return WhitespaceFlag.before | WhitespaceFlag.after;\n      }\n    }\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement(node: t.IfStatement): WhitespaceFlag {\n    if (isBlockStatement(node.consequent)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n};\n\n/**\n * Test if Property needs whitespace.\n */\n\nnodes.ObjectProperty =\n  nodes.ObjectTypeProperty =\n  nodes.ObjectMethod =\n    function (\n      node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,\n      parent: t.ObjectExpression,\n    ): WhitespaceFlag {\n      if (parent.properties[0] === node) {\n        return WhitespaceFlag.before;\n      }\n    };\n\nnodes.ObjectTypeCallProperty = function (\n  node: t.ObjectTypeCallProperty,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (parent.callProperties[0] === node && !parent.properties?.length) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (\n  node: t.ObjectTypeIndexer,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.indexers[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (\n  node: t.ObjectTypeInternalSlot,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.internalSlots[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length &&\n    !parent.indexers?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n(\n  [\n    [\"Function\", true],\n    [\"Class\", true],\n    [\"Loop\", true],\n    [\"LabeledStatement\", true],\n    [\"SwitchStatement\", true],\n    [\"TryStatement\", true],\n  ] as const\n).forEach(function ([type, amounts]) {\n  [type as string]\n    .concat(FLIPPED_ALIAS_KEYS[type] || [])\n    .forEach(function (type) {\n      const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;\n      nodes[type] = () => ret;\n    });\n});\n", "import {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { TokenContext } from \"./index.ts\";\n\nconst PRECEDENCE = new Map([\n  [\"||\", 0],\n  [\"??\", 0],\n  [\"|>\", 0],\n  [\"&&\", 1],\n  [\"|\", 2],\n  [\"^\", 3],\n  [\"&\", 4],\n  [\"==\", 5],\n  [\"===\", 5],\n  [\"!=\", 5],\n  [\"!==\", 5],\n  [\"<\", 6],\n  [\">\", 6],\n  [\"<=\", 6],\n  [\">=\", 6],\n  [\"in\", 6],\n  [\"instanceof\", 6],\n  [\">>\", 7],\n  [\"<<\", 7],\n  [\">>>\", 7],\n  [\"+\", 8],\n  [\"-\", 8],\n  [\"*\", 9],\n  [\"/\", 9],\n  [\"%\", 9],\n  [\"**\", 10],\n]);\n\nfunction getBinaryPrecedence(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  nodeType: string,\n): number;\nfunction getBinaryPrecedence(\n  node: t.Node,\n  nodeType: string,\n): number | undefined;\nfunction getBinaryPrecedence(node: t.Node, nodeType: string) {\n  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n    return PRECEDENCE.get((node as t.Binary).operator);\n  }\n  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n    return PRECEDENCE.get(\"in\");\n  }\n}\n\nfunction isTSTypeExpression(nodeType: string) {\n  return (\n    nodeType === \"TSAsExpression\" ||\n    nodeType === \"TSSatisfiesExpression\" ||\n    nodeType === \"TSTypeAssertion\"\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => {\n  const parentType = parent.type;\n  return (\n    (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") &&\n    parent.superClass === node\n  );\n};\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) => {\n  const parentType = parent.type;\n  return (\n    ((parentType === \"MemberExpression\" ||\n      parentType === \"OptionalMemberExpression\") &&\n      parent.object === node) ||\n    ((parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\") &&\n      parent.callee === node) ||\n    (parentType === \"TaggedTemplateExpression\" && parent.tag === node) ||\n    parentType === \"TSNonNullExpression\"\n  );\n};\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  const parentType = parent.type;\n  return (\n    // (() => A) | (() => B)\n    parentType === \"UnionTypeAnnotation\" ||\n    // (() => A) & (() => B)\n    parentType === \"IntersectionTypeAnnotation\" ||\n    // (() => A)[]\n    parentType === \"ArrayTypeAnnotation\" ||\n    Boolean(tokenContext & TokenContext.arrowFlowReturnType)\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction needsParenBeforeExpressionBrace(tokenContext: number) {\n  return Boolean(\n    tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody),\n  );\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && Boolean(tokenContext & TokenContext.expressionStatement)\n  );\n}\n\nexport function Binary(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean | undefined {\n  const parentType = parent.type;\n  if (\n    node.type === \"BinaryExpression\" &&\n    node.operator === \"**\" &&\n    parentType === \"BinaryExpression\" &&\n    parent.operator === \"**\"\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"AwaitExpression\"\n  ) {\n    return true;\n  }\n\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parentType === \"BinaryExpression\" &&\n        parent.right === node) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n\n  return undefined;\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"ArrayTypeAnnotation\" ||\n    parentType === \"NullableTypeAnnotation\" ||\n    parentType === \"IntersectionTypeAnnotation\" ||\n    parentType === \"UnionTypeAnnotation\"\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\n\nexport function TSAsExpression(\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean {\n  if (\n    (parent.type === \"AssignmentExpression\" ||\n      parent.type === \"AssignmentPattern\") &&\n    parent.left === node\n  ) {\n    return true;\n  }\n  if (\n    parent.type === \"BinaryExpression\" &&\n    (parent.operator === \"|\" || parent.operator === \"&\") &&\n    node === parent.left\n  ) {\n    return true;\n  }\n  return Binary(node, parent);\n}\n\nexport { TSAsExpression as TSSatisfiesExpression };\n\nexport { UnaryLike as TSTypeAssertion };\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSArrayType\" ||\n    parentType === \"TSOptionalType\" ||\n    parentType === \"TSIntersectionType\" ||\n    parentType === \"TSRestType\"\n  );\n}\n\nexport { TSUnionType as TSIntersectionType };\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  return parentType === \"TSArrayType\" || parentType === \"TSOptionalType\";\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  const parentType = parent.type;\n  return (\n    (parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\" ||\n      parentType === \"TSInstantiationExpression\") &&\n    !!(process.env.BABEL_8_BREAKING\n      ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n        parent.typeArguments\n      : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        parent.typeParameters)\n  );\n}\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n  tokenContext: unknown,\n  inForStatementInit: boolean,\n): boolean {\n  // for ((1 in []);;);\n  // for (var x = (1 in []) in 2);\n  return node.operator === \"in\" && inForStatementInit;\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"SequenceExpression\" ||\n    parentType === \"ParenthesizedExpression\" ||\n    (parentType === \"MemberExpression\" && parent.property === node) ||\n    (parentType === \"OptionalMemberExpression\" && parent.property === node) ||\n    parentType === \"TemplateLiteral\"\n  ) {\n    return false;\n  }\n  if (parentType === \"ClassDeclaration\") {\n    return true;\n  }\n  if (parentType === \"ForOfStatement\") {\n    return parent.right === node;\n  }\n  if (parentType === \"ExportDefaultDeclaration\") {\n    return true;\n  }\n\n  return !isStatement(parent);\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    hasPostfixPart(node, parent) ||\n    (parentType === \"AwaitExpression\" && isYieldExpression(node)) ||\n    (parentType === \"ConditionalExpression\" && node === parent.test) ||\n    isClassExtendsClause(node, parent) ||\n    isTSTypeExpression(parentType)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.TSTypeAssertion\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    (isBinaryExpression(parent) &&\n      parent.operator === \"**\" &&\n      parent.left === node) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent?: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    (parentType === \"ConditionalExpression\" && parent.test === node) ||\n    parentType === \"AwaitExpression\" ||\n    isTSTypeExpression(parentType)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport { ConditionalExpression as ArrowFunctionExpression };\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    (isCallExpression(parent) && parent.callee === node) ||\n    (isMemberExpression(parent) && parent.object === node)\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  if (\n    needsParenBeforeExpressionBrace(tokenContext) &&\n    isObjectPattern(node.left)\n  ) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== \"LogicalExpression\") return false;\n  switch (node.operator) {\n    case \"||\":\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return parent.operator === \"??\";\n    case \"??\":\n      return parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  tokenContext: number,\n  _inForInit: boolean,\n  getRawIdentifier: (node: t.Identifier) => string,\n): boolean {\n  const parentType = parent.type;\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    parentType === \"AssignmentExpression\" &&\n    parent.left === node\n  ) {\n    const rightType = parent.right.type;\n    if (\n      (rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") &&\n      parent.right.id == null\n    ) {\n      return true;\n    }\n  }\n\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    if (\n      isFollowedByBracket &&\n      tokenContext &\n        (TokenContext.expressionStatement |\n          TokenContext.forHead |\n          TokenContext.forInHead)\n    ) {\n      return true;\n    }\n    return Boolean(tokenContext & TokenContext.forOfHead);\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  return (\n    node.name === \"async\" &&\n    isForOfStatement(parent, { left: node, await: false })\n  );\n}\n", "import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\nexport const enum TokenContext {\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  forHead = 1 << 3,\n  forInHead = 1 << 4,\n  forOfHead = 1 << 5,\n  arrowFlowReturnType = 1 << 6,\n}\n\ntype NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  inForStatementInit?: boolean,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R;\n\nexport type NodeHandlers<R> = {\n  [K in string]?: NodeHandler<R>;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const map = new Map<string, NodeHandler<R>>();\n\n  function add(type: string, func: NodeHandler<R>) {\n    const fn = map.get(type);\n    map.set(\n      type,\n      fn\n        ? function (node, parent, stack, inForInit, getRawIdentifier) {\n            return (\n              fn(node, parent, stack, inForInit, getRawIdentifier) ??\n              func(node, parent, stack, inForInit, getRawIdentifier)\n            );\n          }\n        : func,\n    );\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return map;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  inForInit?: boolean,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  if (isDecorator(parent)) {\n    return (\n      !isDecoratorMemberExpression(node) &&\n      !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) &&\n      !isParenthesizedExpression(node)\n    );\n  }\n\n  return expandedParens.get(node.type)?.(\n    node,\n    parent,\n    tokenContext,\n    inForInit,\n    getRawIdentifier,\n  );\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n", "import type * as t from \"@babel/types\";\nimport type { Token } from \"@babel/parser\";\n\nimport { traverseFast, VISITOR_KEYS } from \"@babel/types\";\n\nexport class TokenMap {\n  _tokens: Token[];\n  _source: string;\n\n  _nodesToTokenIndexes: Map<t.Node, number[]> = new Map();\n  _nodesOccurrencesCountCache: Map<\n    t.Node,\n    { test: string; count: number; i: number }\n  > = new Map();\n\n  _tokensCache = new Map<t.Node, { first: number; last: number }>();\n\n  constructor(ast: t.Node, tokens: Token[], source: string) {\n    this._tokens = tokens;\n    this._source = source;\n\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n\n    this._tokensCache = null;\n  }\n\n  has(node: t.Node): boolean {\n    return this._nodesToTokenIndexes.has(node);\n  }\n\n  getIndexes(node: t.Node): readonly number[] | undefined {\n    return this._nodesToTokenIndexes.get(node);\n  }\n\n  find(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n\n  findLastIndex(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): number {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n\n  findMatching(\n    node: t.Node,\n    test: string,\n    occurrenceCount: number = 0,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      let i = 0;\n      const count = occurrenceCount;\n\n      // To avoid O(n^2) search when printing lists (such as arrays), we\n      // cache the last index of a given token for a given occurrence count.\n      // If then we are asked to find the next occurrence of the same token,\n      // we start from the index of the previously found token.\n      // This cache only kicks in after 2 tokens of the same type, to avoid\n      // overhead in the simple case of having unique tokens per node.\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if (cache && cache.test === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, { test, count, i });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n\n  matchesOriginal(token: Token, test: string) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n\n  startMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  endMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  _getTokensIndexesOfNode(node: t.Node): number[] {\n    if (node.start == null || node.end == null) return [];\n\n    const { first, last } = this._findTokensOfNode(\n      node,\n      0,\n      this._tokens.length - 1,\n    );\n\n    let low = first;\n\n    const children = childrenIterator(node);\n\n    if (\n      (node.type === \"ExportNamedDeclaration\" ||\n        node.type === \"ExportDefaultDeclaration\") &&\n      node.declaration &&\n      node.declaration.type === \"ClassDeclaration\"\n    ) {\n      // Exported class declarations can be not properly nested inside\n      // the export declaration that contains them. For example, in\n      // `@dec export class Foo {}` the `export` is covered by the\n      // ClassDeclaration range. Skip the class declaration from the list\n      // of children to skip, so that when looking for `export` we also\n      // traverse its tokens.\n      children.next();\n    }\n\n    const indexes = [];\n\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n\n      const childTok = this._findTokensOfNode(child, low, last);\n\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n\n      low = childTok.last + 1;\n    }\n\n    for (let k = low; k <= last; k++) indexes.push(k);\n\n    return indexes;\n  }\n\n  _findTokensOfNode(node: t.Node, low: number, high: number) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n\n    const first = this._findFirstTokenOfNode(node.start, low, high);\n    const last = this._findLastTokenOfNode(node.end, first, high);\n\n    this._tokensCache.set(node, { first, last });\n    return { first, last };\n  }\n\n  _findFirstTokenOfNode(start: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n\n  _findLastTokenOfNode(end: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\n\nfunction* childrenIterator(node: t.Node) {\n  // We need special handling to iterate TemplateLiteral\n  // children in order, since the two lists are interleaved.\n  if (node.type === \"TemplateLiteral\") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = (node as any)[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TaggedTemplateExpression(\n  this: Printer,\n  node: t.TaggedTemplateExpression,\n) {\n  this.print(node.tag);\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.typeArguments);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n    this.print(node.typeParameters);\n  }\n  this.print(node.quasi);\n}\n\nexport function TemplateElement(this: Printer) {\n  throw new Error(\"TemplateElement printing is handled in TemplateLiteral\");\n}\n\nexport function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {\n  const quasis = node.quasis;\n\n  let partRaw = \"`\";\n\n  for (let i = 0; i < quasis.length; i++) {\n    partRaw += quasis[i].value.raw;\n\n    if (i + 1 < quasis.length) {\n      this.token(partRaw + \"${\", true);\n      this.print(node.expressions[i]);\n      partRaw = \"}\";\n\n      // In Babel 7 we have indivirual tokens for ${ and }, so the automatic\n      // catchup logic does not work. Manually look for those tokens.\n      if (!process.env.BABEL_8_BREAKING && this.tokenMap) {\n        const token = this.tokenMap.findMatching(node, \"}\", i);\n        if (token) this._catchUpTo(token.loc.start);\n      }\n    }\n  }\n\n  this.token(partRaw + \"`\", true);\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments);\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // Legacy TS AST\n  }\n\n  // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n  if (node.optional) {\n    // TODO: This can never happen\n    this.token(\"?.\");\n  }\n\n  if (\n    node.arguments.length === 0 &&\n    this.tokenMap &&\n    !this.tokenMap.endMatches(node, \")\")\n  ) {\n    return;\n  }\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  this.print(node.expression);\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee);\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // legacy TS AST\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee);\n\n  this.print(node.typeArguments);\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // legacy TS AST\n  }\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument);\n  }\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  this.word(\"yield\", true);\n\n  if (node.delegate) {\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument);\n    }\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.tokenContext |= TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.token(\"?\");\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression | t.BinaryExpression | t.LogicalExpression,\n) {\n  this.print(node.left);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === \"/\";\n  }\n  this.space();\n\n  this.print(node.right);\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.token(\"[\");\n    this.print(node.property);\n    this.token(\"]\");\n    exit();\n  } else {\n    this.token(\".\");\n    this.print(node.property);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function WithStatement(this: Printer, node: t.WithStatement) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function IfStatement(this: Printer, node: t.IfStatement) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.space();\n\n  const needsBlock =\n    node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(charCodes.rightCurlyBrace)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\n\n// Recursively get the last statement.\nfunction getLastStatement(statement: t.Statement): t.Statement {\n  // @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false\n  const { body } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nexport function ForStatement(this: Printer, node: t.ForStatement) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n\n  {\n    const exit = this.enterForStatementInit();\n    this.tokenContext |= TokenContext.forHead;\n    this.print(node.init);\n    exit();\n  }\n\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.token(\";\", false, 1);\n\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function WhileStatement(this: Printer, node: t.WhileStatement) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction ForXStatement(this: Printer, node: t.ForXStatement) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  {\n    const exit = isForOf ? null : this.enterForStatementInit();\n    this.tokenContext |= isForOf\n      ? TokenContext.forOfHead\n      : TokenContext.forInHead;\n    this.print(node.left);\n    exit?.();\n  }\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport const ForInStatement = ForXStatement;\nexport const ForOfStatement = ForXStatement;\n\nexport function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(printer: Printer, node: t.Node) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n\n  printer.semicolon();\n}\n\nexport function BreakStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ContinueStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ReturnStatement(this: Printer, node: t.ReturnStatement) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function ThrowStatement(this: Printer, node: t.ThrowStatement) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function LabeledStatement(this: Printer, node: t.LabeledStatement) {\n  this.print(node.label);\n  this.token(\":\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function TryStatement(this: Printer, node: t.TryStatement) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n  if (node.handlers) {\n    // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\n\nexport function CatchClause(this: Printer, node: t.CatchClause) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.token(\")\");\n    this.space();\n  }\n  this.print(node.body);\n}\n\nexport function SwitchStatement(this: Printer, node: t.SwitchStatement) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n\n  this.printSequence(\n    node.cases,\n    true,\n    undefined,\n    function addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    },\n  );\n\n  this.rightBrace(node);\n}\n\nexport function SwitchCase(this: Printer, node: t.SwitchCase) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, true);\n  }\n}\n\nexport function DebuggerStatement(this: Printer) {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nexport function VariableDeclaration(\n  this: Printer,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n) {\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  const { kind } = node;\n  if (kind === \"await using\") {\n    this.word(\"await\");\n    this.space();\n    this.word(\"using\", true);\n  } else {\n    this.word(kind, kind === \"using\");\n  }\n  this.space();\n\n  let hasInits = false;\n  // don't add whitespace to loop heads\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   let foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   let foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  this.printList(\n    node.declarations,\n    undefined,\n    undefined,\n    node.declarations.length > 1,\n    hasInits\n      ? function (this: Printer, occurrenceCount: number) {\n          this.token(\",\", false, occurrenceCount);\n          this.newline();\n        }\n      : undefined,\n  );\n\n  if (isFor(parent)) {\n    // don't give semicolons to these nodes since they'll be inserted in the parent generator\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {\n  this.print(node.id);\n  if (node.definite) this.token(\"!\"); // TS\n  // @ts-ignore(Babel 7 vs Babel 8) Property 'typeAnnotation' does not exist on type 'MemberExpression'.\n  this.print(node.id.typeAnnotation);\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init);\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nexport function ClassDeclaration(\n  this: Printer,\n  node: t.ClassDeclaration,\n  parent: t.Node,\n) {\n  const inExport =\n    isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n\n  if (\n    !inExport ||\n    !this._shouldPrintDecoratorsBeforeExport(\n      parent as t.ExportDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    this.printJoin(node.decorators);\n  }\n\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    // TS\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n\n  this.print(node.typeParameters);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass);\n    this.print(\n      process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          node.superTypeArguments\n        : // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          node.superTypeParameters,\n    );\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements);\n  }\n\n  this.space();\n  this.print(node.body);\n}\n\nexport { ClassDeclaration as ClassExpression };\n\nexport function ClassBody(this: Printer, node: t.ClassBody) {\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator?.(-1); // print leading semicolons in preserveFormat mode\n\n    const exit = this.enterDelimited();\n    this.printJoin(node.body, true, true, separator, true);\n    exit();\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace(node);\n  }\n}\n\nfunction classBodyEmptySemicolonsPrinter(printer: Printer, node: t.ClassBody) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n\n  // \"empty statements\" in class bodies are not represented in the AST.\n  // Print them by checking if there are any ; tokens between the current AST\n  // member and the next one.\n\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n\n  let k = 1; // start from 1 to skip '{'\n\n  let occurrenceCount = 0;\n\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (\n      nextLocIndex < node.body.length &&\n      node.body[nextLocIndex].start == null\n    ) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n\n  return (i: number) => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n\n    const end =\n      nextLocIndex === node.body.length\n        ? node.end\n        : node.body[nextLocIndex].start;\n\n    let tok;\n    while (\n      k < indexes.length &&\n      printer.tokenMap.matchesOriginal(\n        (tok = printer._tokens[indexes[k]]),\n        \";\",\n      ) &&\n      tok.start < end\n    ) {\n      printer.token(\";\", undefined, occurrenceCount++);\n      k++;\n    }\n  };\n}\n\nexport function ClassProperty(this: Printer, node: t.ClassProperty) {\n  this.printJoin(node.decorators);\n\n  if (!node.static && !this.format.preserveFormat) {\n    // catch up to property key, avoid line break\n    // between member TS modifiers and the property key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassAccessorProperty(\n  this: Printer,\n  node: t.ClassAccessorProperty,\n) {\n  this.printJoin(node.decorators);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  // TS does not support class accessor property yet\n  this.tsPrintClassMemberModifiers(node);\n\n  this.word(\"accessor\", true);\n  this.space();\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // Todo: Flow does not support class accessor property yet.\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassPrivateProperty(\n  this: Printer,\n  node: t.ClassPrivateProperty,\n) {\n  this.printJoin(node.decorators);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.key);\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassMethod(this: Printer, node: t.ClassMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ClassPrivateMethod(this: Printer, node: t.ClassPrivateMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function _classMethodHead(\n  this: Printer,\n  node: t.ClassMethod | t.ClassPrivateMethod | t.TSDeclareMethod,\n) {\n  this.printJoin(node.decorators);\n\n  if (!this.format.preserveFormat) {\n    // catch up to method key, avoid line break\n    // between member modifiers/method heads and the method key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\n\nexport function StaticBlock(this: Printer, node: t.StaticBlock) {\n  this.word(\"static\");\n  this.space();\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body, true);\n    this.rightBrace(node);\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier, type ParentMaps } from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\ntype ParentsOf<T extends t.Node> = ParentMaps[T[\"type\"]];\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  idNode: t.Expression | t.PrivateName,\n  parentNode: ParentsOf<typeof node>,\n) {\n  this.print(node.typeParameters);\n\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n\n  this.token(\"(\");\n  this._parameters(node.params, \")\");\n\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  endToken: string,\n) {\n  const exit = this.enterDelimited();\n\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i]);\n\n    if (trailingComma || i < paramLength - 1) {\n      this.token(\",\", null, i);\n      this.space();\n    }\n  }\n\n  this.token(endToken);\n  exit();\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n) {\n  this.printJoin(parameter.decorators);\n  this.print(parameter);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key);\n    this.token(\"]\");\n  } else {\n    this.print(key);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  this._params(\n    node,\n    node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    undefined,\n  );\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (this._shouldPrintArrowParamsParens(node)) {\n    this._params(node, undefined, parent);\n  } else {\n    this.print(node.params[0], true);\n  }\n\n  this._predicate(node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.tokenContext |= TokenContext.arrowBody;\n  this.print(node.body);\n}\n\n// Try to avoid printing parens in simple cases, but only if we're pretty\n// sure that they aren't needed by type annotations or potential newlines.\nexport function _shouldPrintArrowParamsParens(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n): boolean {\n  if (node.params.length !== 1) return true;\n\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n\n  const firstParam = node.params[0];\n  if (\n    !isIdentifier(firstParam) ||\n    firstParam.typeAnnotation ||\n    firstParam.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    firstParam.leadingComments?.length ||\n    firstParam.trailingComments?.length\n  ) {\n    return true;\n  }\n\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if (arrowToken?.loc == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n\n  if (this.format.retainLines) return true;\n\n  return false;\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: ParentsOf<t.Function | t.TSDeclareMethod | t.TSDeclareFunction>,\n) {\n  let id: t.Expression | t.PrivateName | t.LVal = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n", "import type Printer from \"../printer.ts\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported);\n}\n\nlet warningShown = false;\n\nexport function _printAttributes(\n  this: Printer,\n  node: Extract<t.Node, { attributes?: t.ImportAttribute[] }>,\n  hasPreviousBrace: boolean,\n) {\n  const { importAttributesKeyword } = this.format;\n  const { attributes, assertions } = node;\n\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    attributes &&\n    !importAttributesKeyword &&\n    // In the production build only show the warning once.\n    // We want to show it per-usage locally for tests.\n    (!process.env.IS_PUBLISH || !warningShown)\n  ) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n  }\n\n  const useAssertKeyword =\n    importAttributesKeyword === \"assert\" ||\n    (!importAttributesKeyword && assertions);\n\n  this.word(useAssertKeyword ? \"assert\" : \"with\");\n  this.space();\n\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    !useAssertKeyword &&\n    importAttributesKeyword !== \"with\"\n  ) {\n    // with-legacy\n    this.printList(attributes || assertions);\n    return;\n  }\n\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n\n  this.token(\"{\", null, occurrenceCount);\n  this.space();\n  this.printList(attributes || assertions, this.shouldPrintTrailingComma(\"}\"));\n  this.space();\n  this.token(\"}\", null, occurrenceCount);\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, false);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nfunction maybePrintDecoratorsBeforeExport(\n  printer: Printer,\n  node: t.ExportNamedDeclaration | t.ExportDefaultDeclaration,\n) {\n  if (\n    isClassDeclaration(node.declaration) &&\n    printer._shouldPrintDecoratorsBeforeExport(\n      node as t.ExportNamedDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    let hasBrace = false;\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      hasBrace = true;\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.attributes?.length || node.assertions?.length) {\n        this.print(node.source, true);\n        this.space();\n        this._printAttributes(node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  this.tokenContext |= TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local);\n}\n\nexport function ImportExpression(this: Printer, node: t.ImportExpression) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.token(\".\");\n    this.word(node.phase);\n  }\n  this.token(\"(\");\n  this.print(node.source);\n  if (node.options != null) {\n    this.token(\",\");\n    this.space();\n    this.print(node.options);\n  }\n  this.token(\")\");\n}\n", "'use strict';\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback) => {\n\tfor (const key in object) {\n\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\tcallback(key, object[key]);\n\t\t}\n\t}\n};\n\nconst extend = (destination, source) => {\n\tif (!source) {\n\t\treturn destination;\n\t}\n\tforOwn(source, (key, value) => {\n\t\tdestination[key] = value;\n\t});\n\treturn destination;\n};\n\nconst forEach = (array, callback) => {\n\tconst length = array.length;\n\tlet index = -1;\n\twhile (++index < length) {\n\t\tcallback(array[index]);\n\t}\n};\n\nconst fourHexEscape = (hex) => {\n\treturn '\\\\u' + ('0000' + hex).slice(-4);\n}\n\nconst hexadecimal = (code, lowercase) => {\n\tlet hexadecimal = code.toString(16);\n\tif (lowercase) return hexadecimal;\n\treturn hexadecimal.toUpperCase();\n};\n\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = (value) => {\n\treturn typeof Buffer === 'function' && Buffer.isBuffer(value);\n};\nconst isObject = (value) => {\n\t// This is a very simple check, but it’s good enough for what we need.\n\treturn toString.call(value) == '[object Object]';\n};\nconst isString = (value) => {\n\treturn typeof value == 'string' ||\n\t\ttoString.call(value) == '[object String]';\n};\nconst isNumber = (value) => {\n\treturn typeof value == 'number' ||\n\t\ttoString.call(value) == '[object Number]';\n};\nconst isFunction = (value) => {\n\treturn typeof value == 'function';\n};\nconst isMap = (value) => {\n\treturn toString.call(value) == '[object Map]';\n};\nconst isSet = (value) => {\n\treturn toString.call(value) == '[object Set]';\n};\n\n/*--------------------------------------------------------------------------*/\n\n// https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t'\n\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t// '\\v': '\\\\x0B'\n};\nconst regexSingleEscape = /[\\\\\\b\\f\\n\\r\\t]/;\n\nconst regexDigit = /[0-9]/;\nconst regexWhitespace = /[\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n\nconst escapeEverythingRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^]/g;\nconst escapeNonAsciiRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^ !#-&\\(-\\[\\]-_a-~]/g;\n\nconst jsesc = (argument, options) => {\n\tconst increaseIndentation = () => {\n\t\toldIndent = indent;\n\t\t++options.indentLevel;\n\t\tindent = options.indent.repeat(options.indentLevel)\n\t};\n\t// Handle options\n\tconst defaults = {\n\t\t'escapeEverything': false,\n\t\t'minimal': false,\n\t\t'isScriptContext': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false,\n\t\t'es6': false,\n\t\t'json': false,\n\t\t'compact': true,\n\t\t'lowercaseHex': false,\n\t\t'numbers': 'decimal',\n\t\t'indent': '\\t',\n\t\t'indentLevel': 0,\n\t\t'__inline1__': false,\n\t\t'__inline2__': false\n\t};\n\tconst json = options && options.json;\n\tif (json) {\n\t\tdefaults.quotes = 'double';\n\t\tdefaults.wrap = true;\n\t}\n\toptions = extend(defaults, options);\n\tif (\n\t\toptions.quotes != 'single' &&\n\t\toptions.quotes != 'double' &&\n\t\toptions.quotes != 'backtick'\n\t) {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ?\n\t\t'\"' :\n\t\t(options.quotes == 'backtick' ?\n\t\t\t'`' :\n\t\t\t'\\''\n\t\t);\n\tconst compact = options.compact;\n\tconst lowercaseHex = options.lowercaseHex;\n\tlet indent = options.indent.repeat(options.indentLevel);\n\tlet oldIndent = '';\n\tconst inline1 = options.__inline1__;\n\tconst inline2 = options.__inline2__;\n\tconst newLine = compact ? '' : '\\n';\n\tlet result;\n\tlet isEmpty = true;\n\tconst useBinNumbers = options.numbers == 'binary';\n\tconst useOctNumbers = options.numbers == 'octal';\n\tconst useDecNumbers = options.numbers == 'decimal';\n\tconst useHexNumbers = options.numbers == 'hexadecimal';\n\n\tif (json && argument && isFunction(argument.toJSON)) {\n\t\targument = argument.toJSON();\n\t}\n\n\tif (!isString(argument)) {\n\t\tif (isMap(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Map()';\n\t\t\t}\n\t\t\tif (!compact) {\n\t\t\t\toptions.__inline1__ = true;\n\t\t\t\toptions.__inline2__ = false;\n\t\t\t}\n\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isSet(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Set()';\n\t\t\t}\n\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isBuffer(argument)) {\n\t\t\tif (argument.length == 0) {\n\t\t\t\treturn 'Buffer.from([])';\n\t\t\t}\n\t\t\treturn 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isArray(argument)) {\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tif (inline1) {\n\t\t\t\toptions.__inline1__ = false;\n\t\t\t\toptions.__inline2__ = true;\n\t\t\t}\n\t\t\tif (!inline2) {\n\t\t\t\tincreaseIndentation();\n\t\t\t}\n\t\t\tforEach(argument, (value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tif (inline2) {\n\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t}\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\tif (inline2) {\n\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t}\n\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t} else if (isNumber(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\treturn JSON.stringify(argument);\n\t\t\t}\n\t\t\tif (useDecNumbers) {\n\t\t\t\treturn String(argument);\n\t\t\t}\n\t\t\tif (useHexNumbers) {\n\t\t\t\tlet hexadecimal = argument.toString(16);\n\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t}\n\t\t\t\treturn '0x' + hexadecimal;\n\t\t\t}\n\t\t\tif (useBinNumbers) {\n\t\t\t\treturn '0b' + argument.toString(2);\n\t\t\t}\n\t\t\tif (useOctNumbers) {\n\t\t\t\treturn '0o' + argument.toString(8);\n\t\t\t}\n\t\t} else if (!isObject(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isn’t valid\n\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t}\n\t\t\treturn String(argument);\n\t\t} else { // it’s an object\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tincreaseIndentation();\n\t\t\tforOwn(argument, (key, value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t}\n\t}\n\n\tconst regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;\n\tresult = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {\n\t\tif (pair) {\n\t\t\tif (options.minimal) return pair;\n\t\t\tconst first = pair.charCodeAt(0);\n\t\t\tconst second = pair.charCodeAt(1);\n\t\t\tif (options.es6) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tconst codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\tconst hex = hexadecimal(codePoint, lowercaseHex);\n\t\t\t\treturn '\\\\u{' + hex + '}';\n\t\t\t}\n\t\t\treturn fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));\n\t\t}\n\n\t\tif (lone) {\n\t\t\treturn fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));\n\t\t}\n\n\t\tif (\n\t\t\tchar == '\\0' &&\n\t\t\t!json &&\n\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t) {\n\t\t\treturn '\\\\0';\n\t\t}\n\n\t\tif (quoteChar) {\n\t\t\tif (quoteChar == quote || options.escapeEverything) {\n\t\t\t\treturn '\\\\' + quoteChar;\n\t\t\t}\n\t\t\treturn quoteChar;\n\t\t}\n\n\t\tif (regexSingleEscape.test(char)) {\n\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\treturn singleEscapes[char];\n\t\t}\n\n\t\tif (options.minimal && !regexWhitespace.test(char)) {\n\t\t\treturn char;\n\t\t}\n\n\t\tconst hex = hexadecimal(char.charCodeAt(0), lowercaseHex);\n\t\tif (json || hex.length > 2) {\n\t\t\treturn fourHexEscape(hex);\n\t\t}\n\n\t\treturn '\\\\x' + ('00' + hex).slice(-2);\n\t});\n\n\tif (quote == '`') {\n\t\tresult = result.replace(/\\$\\{/g, '\\\\${');\n\t}\n\tif (options.isScriptContext) {\n\t\t// https://mathiasbynens.be/notes/etago\n\t\tresult = result\n\t\t\t.replace(/<\\/(script|style)/gi, '<\\\\/$1')\n\t\t\t.replace(/<!--/g, json ? '\\\\u003C!--' : '\\\\x3C!--');\n\t}\n\tif (options.wrap) {\n\t\tresult = quote + result + quote;\n\t}\n\treturn result;\n};\n\njsesc.version = '3.0.2';\n\nmodule.exports = jsesc;\n", "import type Printer from \"../printer.ts\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nlet lastRawIdentNode: t.Identifier | null = null;\nlet lastRawIdentResult: string = \"\";\nexport function _getRawIdentifier(this: Printer, node: t.Identifier) {\n  if (node === lastRawIdentNode) return lastRawIdentResult;\n  lastRawIdentNode = node;\n\n  const { name } = node;\n  const token = this.tokenMap.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return (lastRawIdentResult = node.name);\n}\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.sourceIdentifierName(node.loc?.identifierName || node.name);\n\n  this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    const exit = this.enterDelimited();\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(\"}\"), true, true);\n    this.space();\n    exit();\n  }\n\n  this.sourceWithOffset(\"end\", node.loc, -1);\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value);\n      return;\n    }\n\n    this.print(node.key);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  const exit = this.enterDelimited();\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(\"]\")) {\n        this.token(\",\", false, i);\n      }\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\", false, i);\n    }\n  }\n\n  exit();\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RecordExpression(this: Printer, node: t.RecordExpression) {\n  const props = node.properties;\n\n  let startToken;\n  let endToken;\n  if (process.env.BABEL_8_BREAKING) {\n    startToken = \"#{\";\n    endToken = \"}\";\n  } else {\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n      startToken = \"{|\";\n      endToken = \"|}\";\n    } else if (\n      this.format.recordAndTupleSyntaxType !== \"hash\" &&\n      this.format.recordAndTupleSyntaxType != null\n    ) {\n      throw new Error(\n        `The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(\n          this.format.recordAndTupleSyntaxType,\n        )} received).`,\n      );\n    } else {\n      startToken = \"#{\";\n      endToken = \"}\";\n    }\n  }\n\n  this.token(startToken);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);\n    this.space();\n  }\n  this.token(endToken);\n}\n\nexport function TupleExpression(this: Printer, node: t.TupleExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  let startToken;\n  let endToken;\n  if (process.env.BABEL_8_BREAKING) {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n      startToken = \"[|\";\n      endToken = \"|]\";\n    } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n      startToken = \"#[\";\n      endToken = \"]\";\n    } else {\n      throw new Error(\n        `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,\n      );\n    }\n  }\n\n  this.token(startToken);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {\n        this.token(\",\", false, i);\n      }\n    }\n  }\n\n  this.token(endToken);\n}\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression);\n}\n\nexport function PipelineBareFunction(\n  this: Printer,\n  node: t.PipelineBareFunction,\n) {\n  this.print(node.callee);\n}\n\nexport function PipelinePrimaryTopicReference(this: Printer) {\n  this.token(\"#\");\n}\n", "import type Printer from \"../printer.ts\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules.ts\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id);\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8) Remove this comment, since we'll remove the Noop node\n  this.print(node.id.typeAnnotation.typeAnnotation);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  context.print(node.id);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(node.init);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent?: t.Node,\n) {\n  this.print(node.typeParameters);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n\n  const type = parent?.type;\n  if (\n    type != null &&\n    (type === \"ObjectTypeCallProperty\" ||\n      type === \"ObjectTypeInternalSlot\" ||\n      type === \"DeclareFunction\" ||\n      (type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === \"DeclareClass\") {\n    if (node.mixins?.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if (node.implements?.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  const kind = node.variance?.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.token(\"+\");\n    } else if (kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"&\", false, occurrenceCount);\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, andSeparator);\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types.ts\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(\n  this: Printer,\n  node: t.TypeAnnotation,\n  parent: t.Node,\n) {\n  this.token(\":\");\n  this.space();\n  if (parent.type === \"ArrowFunctionExpression\") {\n    this.tokenContext |= TokenContext.arrowFlowReturnType;\n  } else if (\n    // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n    node.optional\n  ) {\n    this.token(\"?\");\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params);\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(\n      props,\n      true,\n      true,\n      undefined,\n      undefined,\n      function addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      },\n    );\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification);\n  this.token(\".\");\n  this.print(node.id);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"|\", false, occurrenceCount);\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, orSeparator);\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter);\n  }\n\n  this.print(node.program);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  // An empty Program doesn't have any inner tokens, so\n  // we must explicitly print its inner comments.\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, undefined, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, true, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, true);\n\n  exit();\n  this.rightBrace(node);\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 strict\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function JSXAttribute(this: Printer, node: t.JSXAttribute) {\n  this.print(node.name);\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value);\n  }\n}\n\nexport function JSXIdentifier(this: Printer, node: t.JSXIdentifier) {\n  this.word(node.name);\n}\n\nexport function JSXNamespacedName(this: Printer, node: t.JSXNamespacedName) {\n  this.print(node.namespace);\n  this.token(\":\");\n  this.print(node.name);\n}\n\nexport function JSXMemberExpression(\n  this: Printer,\n  node: t.JSXMemberExpression,\n) {\n  this.print(node.object);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function JSXSpreadAttribute(this: Printer, node: t.JSXSpreadAttribute) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\n\nexport function JSXExpressionContainer(\n  this: Printer,\n  node: t.JSXExpressionContainer,\n) {\n  this.token(\"{\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXSpreadChild(this: Printer, node: t.JSXSpreadChild) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXText(this: Printer, node: t.JSXText) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\n\nexport function JSXElement(this: Printer, node: t.JSXElement) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingElement);\n}\n\nfunction spaceSeparator(this: Printer) {\n  this.space();\n}\n\nexport function JSXOpeningElement(this: Printer, node: t.JSXOpeningElement) {\n  this.token(\"<\");\n  this.print(node.name);\n  if (process.env.BABEL_8_BREAKING) {\n    //@ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.typeArguments);\n  } else {\n    if (node.typeArguments) {\n      this.print(node.typeArguments); // Flow AST\n    }\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // Legacy TS AST\n  }\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, undefined, undefined, spaceSeparator);\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/\");\n  }\n  this.token(\">\");\n}\n\nexport function JSXClosingElement(this: Printer, node: t.JSXClosingElement) {\n  this.token(\"<\");\n  this.token(\"/\");\n  this.print(node.name);\n  this.token(\">\");\n}\n\nexport function JSXEmptyExpression(this: Printer) {\n  // This node is empty, so forcefully print its inner comments.\n  this.printInnerComments();\n}\n\nexport function JSXFragment(this: Printer, node: t.JSXFragment) {\n  this.print(node.openingFragment);\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingFragment);\n}\n\nexport function JSXOpeningFragment(this: Printer) {\n  this.token(\"<\");\n  this.token(\">\");\n}\n\nexport function JSXClosingFragment(this: Printer) {\n  this.token(\"</\");\n  this.token(\">\");\n}\n", "import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TSTypeAnnotation(\n  this: Printer,\n  node: t.TSTypeAnnotation,\n  parent: t.Node,\n) {\n  // TODO(@nicolo-ribaudo): investigate not including => in the range\n  // of the return type of an arrow function type\n  this.token(\n    (parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") &&\n      (process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n          parent.returnType\n        : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n          parent.typeAnnotation) === node\n      ? \"=>\"\n      : \":\",\n  );\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n\n  let printTrailingSeparator =\n    parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    // Only force the trailing comma for pre-existing nodes if they\n    // already had a comma (either because they were multi-param, or\n    // because they had a trailing comma)\n    printTrailingSeparator &&= !!this.tokenMap.find(node, t =>\n      this.tokenMap.matchesOriginal(t, \",\"),\n    );\n    // Preseve the trailing comma if it was there before\n    printTrailingSeparator ||= this.shouldPrintTrailingComma(\">\");\n  }\n\n  this.printList(node.params, printTrailingSeparator);\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(\n    !process.env.BABEL_8_BREAKING\n      ? (node.name as unknown as string)\n      : (node.name as unknown as t.Identifier).name,\n  );\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: t.ParentMaps[\"TSDeclareFunction\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left);\n  this.token(\".\");\n  this.print(node.right);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction maybePrintTrailingCommaOrSemicolon(printer: Printer, node: t.Node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.params\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.returnType\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  const typeArguments = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.typeArguments\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeParameters;\n  this.print(node.typeName, !!typeArguments);\n  this.print(typeArguments);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  const typeArguments = process.env.BABEL_8_BREAKING\n    ? //@ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n      node.typeArguments\n    : //@ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n      node.typeParameters;\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, true);\n\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  let hasLeadingToken = 0;\n  if (printer.tokenMap?.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, null, i + hasLeadingToken);\n    this.space();\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeAnnotation } = node;\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.word(node.key.name);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.word(node.typeParameter.name);\n  }\n\n  this.space();\n  this.word(\"in\");\n  this.space();\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.print(node.constraint);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.print(node.typeParameter.constraint);\n  }\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  if (typeAnnotation) {\n    this.token(\":\");\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal);\n}\n\nexport function TSClassImplements(\n  this: Printer,\n  // TODO(Babel 8): Just use t.TSClassImplements\n  node: t.Node & {\n    expression: t.TSEntityName;\n    typeArguments?: t.TSTypeParameterInstantiation;\n  },\n) {\n  this.print(node.expression);\n  this.print(node.typeArguments);\n}\n\nexport { TSClassImplements as TSInterfaceHeritage };\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\n\nfunction TSTypeExpression(\n  this: Printer,\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n) {\n  const { type, expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport {\n  TSTypeExpression as TSAsExpression,\n  TSTypeExpression as TSSatisfiesExpression,\n};\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation);\n  this.token(\">\");\n  this.space();\n  this.print(expression);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression);\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.typeArguments);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters);\n  }\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n    this.print(node.body);\n  } else {\n    // cast to TSEnumBody for Babel 7 AST\n    TSEnumBody.call(this, node as unknown as t.TSEnumBody);\n  }\n}\n\nexport function TSEnumBody(this: Printer, node: t.TSEnumBody) {\n  printBraced(this, node, () =>\n    this.printList(\n      node.members,\n      this.shouldPrintTrailingComma(\"}\") ??\n        (process.env.BABEL_8_BREAKING ? false : true),\n      true,\n      true,\n    ),\n  );\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer);\n  }\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, id, kind } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (process.env.BABEL_8_BREAKING) {\n    if (kind !== \"global\") {\n      this.word(kind);\n      this.space();\n    }\n\n    this.print(node.id);\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n    this.space();\n    this.print(node.body);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    if (!node.global) {\n      this.word(kind ?? (id.type === \"Identifier\" ? \"namespace\" : \"module\"));\n      this.space();\n    }\n\n    this.print(id);\n\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n\n    let body = node.body;\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    while (body.type === \"TSModuleDeclaration\") {\n      this.token(\".\");\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      this.print(body.id);\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      body = body.body;\n    }\n\n    this.space();\n    this.print(body);\n  }\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { argument, qualifier, options } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument);\n  if (options) {\n    this.token(\",\");\n    this.print(options);\n  }\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier);\n  }\n  const typeArguments = process.env.BABEL_8_BREAKING\n    ? //@ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n      node.typeArguments\n    : //@ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n      node.typeParameters;\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { isExport, id, moduleReference } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression);\n  this.token(\"!\");\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\n\nexport function tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? node.params\n    : node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  const returnType = process.env.BABEL_8_BREAKING\n    ? node.returnType\n    : node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [\n    isField && node.declare && \"declare\",\n    node.accessibility,\n  ]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [\n    node.override && \"override\",\n    node.abstract && \"abstract\",\n    isField && node.readonly && \"readonly\",\n  ]);\n}\n\nfunction printBraced(printer: Printer, node: t.Node, cb: () => void) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\n\nfunction printModifiersList(\n  printer: Printer,\n  node: t.Node,\n  modifiers: (string | false | null)[],\n) {\n  const modifiersSet = new Set<string>();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n\n  printer.tokenMap?.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n  });\n\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n", "export * from \"./template-literals.ts\";\nexport * from \"./expressions.ts\";\nexport * from \"./statements.ts\";\nexport * from \"./classes.ts\";\nexport * from \"./methods.ts\";\nexport * from \"./modules.ts\";\nexport * from \"./types.ts\";\nexport * from \"./flow.ts\";\nexport * from \"./base.ts\";\nexport * from \"./jsx.ts\";\nexport * from \"./typescript.ts\";\n", "import type Printer from \"../printer\";\nimport type * as t from \"@babel/types\";\n\nexport type DeprecatedBabel7ASTTypes =\n  | \"Noop\"\n  | \"TSExpressionWithTypeArguments\"\n  | \"DecimalLiteral\";\n\nexport function addDeprecatedGenerators(PrinterClass: typeof Printer) {\n  // Add Babel 7 generator methods that is removed in Babel 8\n  if (!process.env.BABEL_8_BREAKING) {\n    const deprecatedBabel7Generators = {\n      Noop(this: Printer) {},\n\n      TSExpressionWithTypeArguments(\n        this: Printer,\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n        node: t.TSExpressionWithTypeArguments,\n      ) {\n        this.print(node.expression);\n        this.print(node.typeParameters);\n      },\n\n      DecimalLiteral(this: Printer, node: any) {\n        const raw = this.getPossibleRaw(node);\n        if (!this.format.minified && raw !== undefined) {\n          this.word(raw);\n          return;\n        }\n        this.word(node.value + \"m\");\n      },\n    } satisfies Record<\n      DeprecatedBabel7ASTTypes,\n      (this: Printer, node: any) => void\n    >;\n    Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);\n  }\n}\n", "import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\nimport type { GeneratorOptions } from \"./index.ts\";\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport {\n  addDeprecatedGenerators,\n  type DeprecatedBabel7ASTTypes,\n} from \"./generators/deprecated.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nconst { needsParens } = n;\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies’ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap,\n    tokens?: Token[],\n    originalCode?: string,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n  }\n  declare _inputMap: TraceMap;\n\n  declare format: Format;\n\n  inForStatementInit: boolean = false;\n  enterForStatementInit() {\n    if (this.inForStatementInit) return () => {};\n    this.inForStatementInit = true;\n    return () => {\n      this.inForStatementInit = false;\n    };\n  }\n\n  enterDelimited() {\n    const oldInForStatementInit = this.inForStatementInit;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (\n      oldInForStatementInit === false &&\n      oldNoLineTerminatorAfterNode === null\n    ) {\n      return () => {};\n    }\n    this.inForStatementInit = false;\n    this._noLineTerminatorAfterNode = null;\n    return () => {\n      this.inForStatementInit = oldInForStatementInit;\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    };\n  }\n\n  tokenContext: number = 0;\n\n  _tokens: Token[] = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _endsWithDiv = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n  tokenMap: TokenMap = null;\n\n  _boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens, this._originalCode);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent--;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode);\n        this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(charCodes.semicolon);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    const { format } = this;\n    if (format.compact || format.preserveFormat) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext = 0;\n\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (this._endsWithDiv && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(str: string, maybeNewline = false, occurrenceCount = 0): void {\n    this.tokenContext = 0;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this.tokenContext = 0;\n\n    const str = String.fromCharCode(char);\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _catchUpToCurrentToken(str: string, occurrenceCount: number = 0): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap.findMatching(\n      this._currentNode,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._buf.appendChar(charCodes.semicolon);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n      this._endsWithDiv = false;\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _queue(char: number) {\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const { format } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null,\n    noLineTerminatorAfter?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          | DeprecatedBabel7ASTTypes\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const parent = this._currentNode;\n    this._currentNode = node;\n\n    if (this.tokenMap) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const parenthesized = node.extra?.parenthesized as boolean | undefined;\n    let shouldPrintParens =\n      (parenthesized && format.preserveFormat) ||\n      (parenthesized &&\n        format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\") ||\n      needsParens(\n        node,\n        parent,\n        this.tokenContext,\n        this.inForStatementInit,\n        format.preserveFormat ? this._boundGetRawIdentifier : undefined,\n      );\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      const parentType = parent?.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (this.format.retainLines &&\n          node.loc &&\n          node.loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    let oldInForStatementInitWasTrue;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        n.isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.inForStatementInit) {\n        oldInForStatementInitWasTrue = true;\n        this.inForStatementInit = false;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(\n      loc,\n      // @ts-expect-error Expected 1 arguments, but got 3.\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldInForStatementInitWasTrue) this.inForStatementInit = true;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"],\n    printTrailingSeparator?: boolean,\n    addNewlines?: PrintJoinOptions[\"addNewlines\"],\n    iterator?: PrintJoinOptions[\"iterator\"],\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const boundSeparator = separator?.bind(this);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, undefined, trailingCommentsLineOffset || 0);\n\n      iterator?.(node, i);\n\n      if (boundSeparator != null) {\n        if (i < len - 1) boundSeparator(i, false);\n        else if (printTrailingSeparator) boundSeparator(i, true);\n      }\n\n      if (statement) {\n        if (!node.trailingComments?.length) {\n          this._lastCommentLine = 0;\n        }\n\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    if (this._endsWithInnerRaw) {\n      this.printInnerComments(\n        this.tokenMap?.findMatching(\n          this._currentNode,\n          nextTokenStr,\n          nextTokenOccurrenceCount,\n        ),\n      );\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments(nextToken?: Token) {\n    const node = this._currentNode;\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(\n      COMMENT_TYPE.INNER,\n      comments,\n      node,\n      undefined,\n      undefined,\n      nextToken,\n    );\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    trailingCommentsLineOffset?: number,\n    addNewlines?: PrintSequenceOptions[\"addNewlines\"],\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      addNewlines,\n      undefined,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[],\n    printTrailingSeparator?: boolean,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    iterator?: PrintListOptions[\"iterator\"],\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      undefined,\n      iterator,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, token =>\n      this.tokenMap.matchesOriginal(token, listEnd),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], \",\");\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace &&\n      lastCharCode !== charCodes.leftParenthesis\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid converting a / operator into a line comment by appending /* to it\n    if (this._endsWithDiv) this._space();\n\n    if (this.tokenMap) {\n      const { _printSemicolonBeforeNextToken, _printSemicolonBeforeNextNode } =\n        this;\n      this._printSemicolonBeforeNextToken = -1;\n      this._printSemicolonBeforeNextNode = -1;\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;\n      this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;\n    } else {\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n    }\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n    nextToken?: Token,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumMember(node);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  addDeprecatedGenerators(Printer);\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.token(\",\", false, occurrenceCount);\n  if (!last) this.space();\n}\n", "import SourceMap from \"./source-map.ts\";\nimport Printer from \"./printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\nimport type { Format } from \"./printer.ts\";\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\n/**\n * Normalize generator options, setting defaults.\n *\n * - Detects code indentation.\n * - If `opts.compact = \"auto\"` and the code is over 500KB, `compact` will be set to `true`.\n */\n\nfunction normalizeOptions(\n  code: string | { [filename: string]: string },\n  opts: GeneratorOptions,\n  ast: t.Node,\n): Format {\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== \"string\") {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string\",\n      );\n    }\n    if (!opts.retainLines) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires `retainLines` to be set to `true`\",\n      );\n    }\n    if (opts.compact && opts.compact !== \"auto\") {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `compact` option\",\n      );\n    }\n    if (opts.minified) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `minified` option\",\n      );\n    }\n    if (opts.jsescOption) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `jsescOption` option\",\n      );\n    }\n    if (!Array.isArray((ast as any).tokens)) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.\",\n      );\n    }\n  }\n\n  const format: Format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n    },\n    jsescOption: {\n      quotes: \"double\",\n      wrap: true,\n      minimal: process.env.BABEL_8_BREAKING ? true : false,\n      ...opts.jsescOption,\n    },\n    topicToken: opts.topicToken,\n    importAttributesKeyword: opts.importAttributesKeyword,\n  };\n\n  if (!process.env.BABEL_8_BREAKING) {\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n    format.recordAndTupleSyntaxType = opts.recordAndTupleSyntaxType ?? \"hash\";\n  }\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment =\n      format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment =\n      format.shouldPrintComment ||\n      (value =>\n        format.comments ||\n        value.includes(\"@license\") ||\n        value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500_000; // 500KB\n\n    if (format.compact) {\n      console.error(\n        \"[BABEL] Note: The code generator has deoptimised the styling of \" +\n          `${opts.filename} as it exceeds the max of ${\"500KB\"}.`,\n      );\n    }\n  }\n\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } =\n    format;\n\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n\n  return format;\n}\n\nexport interface GeneratorOptions {\n  /**\n   * Optional string to add as a block comment at the start of the output file.\n   */\n  auxiliaryCommentBefore?: string;\n\n  /**\n   * Optional string to add as a block comment at the end of the output file.\n   */\n  auxiliaryCommentAfter?: string;\n\n  /**\n   * Function that takes a comment (as a string) and returns true if the comment should be included in the output.\n   * By default, comments are included if `opts.comments` is `true` or if `opts.minified` is `false` and the comment\n   * contains `@preserve` or `@license`.\n   */\n  shouldPrintComment?(comment: string): boolean;\n\n  /**\n   * Preserve the input code format while printing the transformed code.\n   * This is experimental, and may have breaking changes in future\n   * patch releases. It will be removed in a future minor release,\n   * when it will graduate to stable.\n   */\n  experimental_preserveFormat?: boolean;\n\n  /**\n   * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).\n   * Defaults to `false`.\n   */\n  retainLines?: boolean;\n\n  /**\n   * Retain parens around function expressions (could be used to change engine parsing behavior)\n   * Defaults to `false`.\n   */\n  retainFunctionParens?: boolean;\n\n  /**\n   * Should comments be included in output? Defaults to `true`.\n   */\n  comments?: boolean;\n\n  /**\n   * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.\n   */\n  compact?: boolean | \"auto\";\n\n  /**\n   * Should the output be minified. Defaults to `false`.\n   */\n  minified?: boolean;\n\n  /**\n   * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.\n   */\n  concise?: boolean;\n\n  /**\n   * Used in warning messages\n   */\n  filename?: string;\n\n  /**\n   * Enable generating source maps. Defaults to `false`.\n   */\n  sourceMaps?: boolean;\n\n  inputSourceMap?: any;\n\n  /**\n   * A root for all relative URLs in the source map.\n   */\n  sourceRoot?: string;\n\n  /**\n   * The filename for the source code (i.e. the code in the `code` argument).\n   * This will only be used if `code` is a string.\n   */\n  sourceFileName?: string;\n\n  /**\n   * Set to true to run jsesc with \"json\": true to print \"\\u00A9\" vs. \"©\";\n   * @deprecated use `jsescOptions: { json: true }` instead\n   */\n  jsonCompatibleStrings?: boolean;\n\n  /**\n   * Set to true to enable support for experimental decorators syntax before\n   * module exports. If not specified, decorators will be printed in the same\n   * position as they were in the input source code.\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n\n  /**\n   * Options for outputting jsesc representation.\n   */\n  jsescOption?: jsescOptions;\n\n  /**\n   * For use with the recordAndTuple token.\n   * @deprecated It will be removed in Babel 8.\n   */\n  recordAndTupleSyntaxType?: \"bar\" | \"hash\";\n\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies’ topic references.\n   */\n  topicToken?: \"%\" | \"#\" | \"@@\" | \"^^\" | \"^\";\n\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n}\n\nexport interface GeneratorResult {\n  code: string;\n  map: EncodedSourceMap | null;\n  decodedMap: DecodedSourceMap | undefined;\n  rawMappings: Mapping[] | undefined;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * We originally exported the Generator class above, but to make it extra clear that it is a private API,\n   * we have moved that to an internal class instance and simplified the interface to the two public methods\n   * that we wish to support.\n   */\n\n  // eslint-disable-next-line no-restricted-globals\n  exports.CodeGenerator = class CodeGenerator {\n    private _ast: t.Node;\n    private _format: Format | undefined;\n    private _map: SourceMap | null;\n    constructor(ast: t.Node, opts: GeneratorOptions = {}, code?: string) {\n      this._ast = ast;\n      this._format = normalizeOptions(code, opts, ast);\n      this._map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n    }\n    generate(): GeneratorResult {\n      const printer = new Printer(this._format, this._map);\n\n      return printer.generate(this._ast);\n    }\n  };\n}\n\n/**\n * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.\n * @param ast - the abstract syntax tree from which to generate output code.\n * @param opts - used for specifying options for code generation.\n * @param code - the original source code, used for source maps.\n * @returns - an object containing the output code and source map.\n */\nexport default function generate(\n  ast: t.Node,\n  opts: GeneratorOptions = {},\n  code?: string | { [filename: string]: string },\n): GeneratorResult {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n\n  const printer = new Printer(\n    format,\n    map,\n    (ast as any).tokens,\n    typeof code === \"string\" ? code : null,\n  );\n\n  return printer.generate(ast);\n}\n"],
  "mappings": "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",
  "names": ["url", "sourceIndex", "encode", "decode", "bsFound", "SetArray", "put", "remove", "encode", "TraceMap", "decodedMappings", "_genMapping", "require", "_traceMapping", "SourceMap", "constructor", "opts", "code", "_opts$sourceFileName", "_map", "_rawMappings", "_sourceFileName", "_lastGenLine", "_lastSourceLine", "_lastSourceColumn", "_inputMap", "map", "GenMapping", "sourceRoot", "sourceFileName", "replace", "undefined", "inputSourceMap", "TraceMap", "resolvedSources", "length", "i", "_this$_inputMap$sourc", "setSourceContent", "sourcesContent", "Object", "keys", "get", "toEncodedMap", "getDecoded", "toDecodedMap", "getRawMappings", "allMappings", "mark", "generated", "line", "column", "identifierName", "identifierNamePos", "filename", "_originalMapping", "originalMapping", "originalPositionFor", "name", "originalIdentifierMapping", "source", "maybeAddMapping", "original", "exports", "default", "Buffer", "constructor", "map", "indentChar", "_map", "_buf", "_str", "_appendCount", "_last", "_queue", "_queueCursor", "_canMarkIdName", "_indentChar", "_fastIndentations", "_position", "line", "column", "_sourcePosition", "identifierName", "undefined", "identifierNamePos", "filename", "i", "push", "repeat", "_allocQueue", "queue", "char", "_pushQueue", "cursor", "length", "item", "_popQueue", "Error", "get", "_flush", "result", "code", "trimRight", "decodedMap", "getDecoded", "__mergedMap", "resultMap", "value", "Object", "defineProperty", "writable", "rawMappings", "mappings", "getRawMappings", "append", "str", "maybeNewline", "_append", "appendChar", "_appendChar", "sourcePosition", "queueIndentation", "queueCursor", "sourcePos", "fastIndentation", "String", "fromCharCode", "_mark", "len", "position", "charCodeAt", "indexOf", "last", "_this$_map", "mark", "removeTrailingNewline", "removeLastSemicolon", "getLastChar", "getNewlineCount", "count", "endsWithCharAndNewline", "lastCp", "hasContent", "exactSource", "loc", "cb", "source", "prop", "_normalizePosition", "sourceWithOffset", "columnOffset", "pos", "target", "Math", "max", "getCurrentColumn", "lastIndex", "getCurrentLine", "exports", "default", "_t", "require", "FLIPPED_ALIAS_KEYS", "isArrayExpression", "isAssignmentExpression", "isBinary", "isBlockStatement", "isCallExpression", "isFunction", "isIdentifier", "isLiteral", "isMemberExpression", "isObjectExpression", "isOptionalCallExpression", "isOptionalMemberExpression", "isStringLiteral", "crawlInternal", "node", "state", "object", "computed", "property", "left", "right", "hasCall", "callee", "hasFunction", "hasHelper", "isHelper", "crawl", "name", "charCodeAt", "isType", "nodes", "exports", "AssignmentExpression", "SwitchCase", "parent", "consequent", "length", "cases", "LogicalExpression", "Literal", "value", "CallExpression", "OptionalCallExpression", "VariableDeclaration", "i", "declarations", "declar", "enabled", "id", "init", "IfStatement", "ObjectProperty", "ObjectTypeProperty", "ObjectMethod", "properties", "ObjectTypeCallProperty", "_parent$properties", "callProperties", "ObjectTypeIndexer", "_parent$properties2", "_parent$callPropertie", "indexers", "ObjectTypeInternalSlot", "_parent$properties3", "_parent$callPropertie2", "_parent$indexers", "internalSlots", "forEach", "type", "amounts", "concat", "ret", "_t", "require", "_index", "isArrayTypeAnnotation", "isBinaryExpression", "isCallExpression", "isForOfStatement", "isIndexedAccessType", "isMemberExpression", "isObjectPattern", "isOptionalMemberExpression", "isYieldExpression", "isStatement", "PRECEDENCE", "Map", "getBinaryPrecedence", "node", "nodeType", "get", "operator", "isTSTypeExpression", "isClassExtendsClause", "parent", "parentType", "type", "superClass", "hasPostfixPart", "object", "callee", "tag", "NullableTypeAnnotation", "FunctionTypeAnnotation", "tokenContext", "Boolean", "TokenContext", "arrowFlowReturnType", "UpdateExpression", "needsParenBeforeExpressionBrace", "expressionStatement", "arrowBody", "ObjectExpression", "DoExpression", "async", "Binary", "left", "parentPos", "nodePos", "right", "undefined", "UnionTypeAnnotation", "OptionalIndexedAccessType", "objectType", "TSAsExpression", "TSUnionType", "TSInferType", "TSInstantiationExpression", "typeParameters", "BinaryExpression", "inForStatementInit", "SequenceExpression", "property", "YieldExpression", "test", "ClassExpression", "exportDefault", "UnaryLike", "FunctionExpression", "ConditionalExpression", "OptionalMemberExpression", "AssignmentExpression", "LogicalExpression", "Identifier", "_inForInit", "getRawIdentifier", "_node$extra", "extra", "parenthesized", "rightType", "id", "name", "isFollowedByBracket", "computed", "optional", "forHead", "forInHead", "forOfHead", "await", "whitespace", "require", "parens", "_t", "FLIPPED_ALIAS_KEYS", "VISITOR_KEYS", "isCallExpression", "isDecorator", "isExpressionStatement", "isMemberExpression", "isNewExpression", "isParenthesizedExpression", "TokenContext", "exports", "expressionStatement", "arrowBody", "exportDefault", "forHead", "forInHead", "forOfHead", "arrowFlowReturnType", "expandAliases", "obj", "map", "Map", "add", "type", "func", "fn", "get", "set", "node", "parent", "stack", "inForInit", "getRawIdentifier", "_fn", "Object", "keys", "aliases", "alias", "expandedParens", "expandedWhitespaceNodes", "nodes", "isOrHasCallExpression", "object", "needsWhitespace", "_expandedWhitespaceNo", "expression", "flag", "needsWhitespaceBefore", "needsWhitespaceAfter", "needsParens", "tokenContext", "_expandedParens$get", "callee", "isDecoratorMemberExpression", "computed", "property", "isLastChild", "child", "visitorKeys", "i", "length", "val", "Array", "isArray", "j", "_t", "require", "traverseFast", "VISITOR_KEYS", "TokenMap", "constructor", "ast", "tokens", "source", "_tokens", "_source", "_nodesToTokenIndexes", "Map", "_nodesOccurrencesCountCache", "_tokensCache", "node", "indexes", "_getTokensIndexesOfNode", "length", "set", "has", "getIndexes", "get", "find", "condition", "k", "index", "tok", "findLastIndex", "findMatching", "test", "occurrenceCount", "i", "count", "cache", "matchesOriginal", "token", "end", "start", "value", "startsWith", "startMatches", "endMatches", "first", "last", "_findTokensOfNode", "low", "children", "childrenIterator", "type", "declaration", "next", "child", "childTok", "high", "push", "cached", "_findFirstTokenOfNode", "_findLastTokenOfNode", "mid", "exports", "quasis", "expressions", "keys", "key", "Array", "isArray", "TaggedTemplateExpression", "node", "print", "tag", "typeParameters", "quasi", "TemplateElement", "Error", "TemplateLiteral", "quasis", "partRaw", "i", "length", "value", "raw", "token", "expressions", "tokenMap", "findMatching", "_catchUpTo", "loc", "start", "_t", "require", "_index", "isCallExpression", "isLiteral", "isMemberExpression", "isNewExpression", "isPattern", "UnaryExpression", "node", "operator", "word", "space", "token", "print", "argument", "DoExpression", "async", "body", "ParenthesizedExpression", "exit", "enterDelimited", "expression", "rightParens", "UpdateExpression", "prefix", "ConditionalExpression", "test", "consequent", "alternate", "NewExpression", "parent", "callee", "format", "minified", "arguments", "length", "optional", "typeArguments", "typeParameters", "tokenMap", "endMatches", "printList", "shouldPrintTrailingComma", "SequenceExpression", "expressions", "ThisExpression", "Super", "_shouldPrintDecoratorsBeforeExport", "decoratorsBeforeExport", "start", "declaration", "Decorator", "newline", "OptionalMemberExpression", "computed", "property", "object", "TypeError", "value", "OptionalCallExpression", "CallExpression", "Import", "AwaitExpression", "printTerminatorless", "YieldExpression", "delegate", "EmptyStatement", "semicolon", "ExpressionStatement", "tokenContext", "TokenContext", "expressionStatement", "AssignmentPattern", "left", "type", "typeAnnotation", "right", "AssignmentExpression", "_endsWithDiv", "BindExpression", "MemberExpression", "MetaProperty", "meta", "PrivateName", "id", "V8IntrinsicIdentifier", "name", "ModuleExpression", "indent", "directives", "dedent", "rightBrace", "_t", "require", "_index", "isFor", "isForStatement", "isIfStatement", "isStatement", "WithStatement", "node", "word", "space", "token", "print", "object", "printBlock", "IfStatement", "test", "needsBlock", "alternate", "getLastStatement", "consequent", "newline", "indent", "printAndIndentOnComments", "dedent", "endsWith", "statement", "body", "ForStatement", "exit", "enterForStatementInit", "tokenContext", "TokenContext", "forHead", "init", "update", "WhileStatement", "ForXStatement", "isForOf", "type", "await", "noIndentInnerCommentsHere", "forOfHead", "forInHead", "left", "right", "ForInStatement", "exports", "ForOfStatement", "DoWhileStatement", "semicolon", "printStatementAfterKeyword", "printer", "printTerminatorless", "BreakStatement", "label", "ContinueStatement", "ReturnStatement", "argument", "ThrowStatement", "LabeledStatement", "TryStatement", "block", "handlers", "handler", "finalizer", "CatchClause", "param", "typeAnnotation", "SwitchStatement", "discriminant", "printSequence", "cases", "undefined", "addNewlines", "leading", "cas", "length", "rightBrace", "SwitchCase", "DebuggerStatement", "VariableDeclaration", "parent", "declare", "kind", "hasInits", "declar", "declarations", "printList", "occurrenceCount", "VariableDeclarator", "id", "definite", "_t", "require", "isExportDefaultDeclaration", "isExportNamedDeclaration", "ClassDeclaration", "node", "parent", "inExport", "_shouldPrintDecoratorsBeforeExport", "printJoin", "decorators", "declare", "word", "space", "abstract", "id", "print", "typeParameters", "superClass", "superTypeParameters", "implements", "printList", "body", "ClassBody", "token", "length", "newline", "separator", "classBodyEmptySemicolonsPrinter", "exit", "enterDelimited", "endsWith", "rightBrace", "printer", "tokenMap", "start", "end", "indexes", "getIndexes", "k", "occurrenceCount", "nextLocIndex", "advanceNextLocIndex", "i", "tok", "matchesOriginal", "_tokens", "undefined", "ClassProperty", "static", "format", "preserveFormat", "_node$key$loc", "endLine", "key", "loc", "line", "catchUp", "tsPrintClassMemberModifiers", "computed", "_variance", "optional", "definite", "typeAnnotation", "value", "semicolon", "ClassAccessorProperty", "_node$key$loc2", "ClassPrivateProperty", "ClassMethod", "_classMethodHead", "ClassPrivateMethod", "_node$key$loc3", "_methodHead", "StaticBlock", "printSequence", "_t", "require", "_index", "isIdentifier", "_params", "node", "idNode", "parentNode", "print", "typeParameters", "nameInfo", "_getFuncIdName", "call", "sourceIdentifierName", "name", "pos", "token", "_parameters", "params", "noLineTerminator", "type", "returnType", "_noLineTerminator", "parameters", "endToken", "exit", "enterDelimited", "trailingComma", "shouldPrintTrailingComma", "paramLength", "length", "i", "_param", "space", "parameter", "printJoin", "decorators", "optional", "typeAnnotation", "_methodHead", "kind", "key", "word", "async", "generator", "computed", "undefined", "_predicate", "noLineTerminatorAfter", "predicate", "_functionHead", "parent", "format", "preserveFormat", "_endsWithInnerRaw", "id", "FunctionExpression", "body", "ArrowFunctionExpression", "_shouldPrintArrowParamsParens", "printInnerComments", "tokenContext", "TokenContext", "arrowBody", "_firstParam$leadingCo", "_firstParam$trailingC", "firstParam", "leadingComments", "trailingComments", "tokenMap", "loc", "findMatching", "arrowToken", "start", "line", "retainLines", "parentType", "left", "_id$loc", "_id$loc2", "identifierName", "_id$loc3", "_id$loc4", "value", "_t", "require", "_index", "isClassDeclaration", "isExportDefaultSpecifier", "isExportNamespaceSpecifier", "isImportDefaultSpecifier", "isImportNamespaceSpecifier", "isStatement", "ImportSpecifier", "node", "importKind", "word", "space", "print", "imported", "local", "name", "ImportDefaultSpecifier", "ExportDefaultSpecifier", "exported", "ExportSpecifier", "exportKind", "ExportNamespaceSpecifier", "token", "warningShown", "_printAttributes", "hasPreviousBrace", "importAttributesKeyword", "format", "attributes", "assertions", "console", "warn", "useAssertKeyword", "printList", "occurrenceCount", "shouldPrintTrailingComma", "ExportAllDeclaration", "_node$attributes", "_node$assertions", "length", "source", "semicolon", "maybePrintDecoratorsBeforeExport", "printer", "declaration", "_shouldPrintDecoratorsBeforeExport", "printJoin", "decorators", "ExportNamedDeclaration", "declar", "specifiers", "slice", "hasSpecial", "first", "shift", "hasBrace", "_node$attributes2", "_node$assertions2", "ExportDefaultDeclaration", "noIndentInnerCommentsHere", "tokenContext", "TokenContext", "exportDefault", "ImportDeclaration", "_node$attributes3", "_node$assertions3", "isTypeKind", "module", "phase", "hasSpecifiers", "ImportAttribute", "key", "value", "ImportNamespaceSpecifier", "ImportExpression", "options", "object", "hexadecimal", "hex", "_t", "require", "_jsesc", "isAssignmentPattern", "isIdentifier", "lastRawIdentNode", "lastRawIdentResult", "_getRawIdentifier", "node", "name", "token", "tokenMap", "find", "tok", "value", "_originalCode", "slice", "start", "end", "Identifier", "_node$loc", "sourceIdentifierName", "loc", "identifierName", "word", "ArgumentPlaceholder", "RestElement", "print", "argument", "ObjectExpression", "props", "properties", "length", "exit", "enterDelimited", "space", "printList", "shouldPrintTrailingComma", "sourceWithOffset", "ObjectMethod", "printJoin", "decorators", "_methodHead", "body", "ObjectProperty", "computed", "key", "left", "shorthand", "ArrayExpression", "elems", "elements", "len", "i", "elem", "RecordExpression", "startToken", "endToken", "format", "recordAndTupleSyntaxType", "Error", "JSON", "stringify", "TupleExpression", "RegExpLiteral", "pattern", "flags", "BooleanLiteral", "NullLiteral", "NumericLiteral", "raw", "getPossibleRaw", "opts", "jsescOption", "str", "numbers", "number", "jsesc", "minified", "StringLiteral", "undefined", "val", "BigIntLiteral", "validTopicTokenSet", "Set", "TopicReference", "topicToken", "has", "givenTopicTokenJSON", "validTopics", "Array", "from", "v", "join", "PipelineTopicExpression", "expression", "PipelineBareFunction", "callee", "PipelinePrimaryTopicReference", "_t", "require", "_modules", "_index", "_types2", "isDeclareExportDeclaration", "isStatement", "AnyTypeAnnotation", "word", "ArrayTypeAnnotation", "node", "print", "elementType", "token", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "value", "NullLiteralTypeAnnotation", "DeclareClass", "parent", "space", "_interfaceish", "DeclareFunction", "id", "typeAnnotation", "predicate", "semicolon", "InferredPredicate", "DeclaredPredicate", "DeclareInterface", "InterfaceDeclaration", "DeclareModule", "body", "DeclareModuleExports", "DeclareTypeAlias", "TypeAlias", "DeclareOpaqueType", "OpaqueType", "DeclareVariable", "DeclareExportDeclaration", "default", "FlowExportDeclaration", "call", "DeclareExportAllDeclaration", "ExportAllDeclaration", "EnumDeclaration", "enumExplicitType", "context", "name", "hasExplicitType", "enumBody", "members", "indent", "newline", "member", "hasUnknownMembers", "dedent", "EnumBooleanBody", "explicitType", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody", "EnumDefaultedMember", "enumInitializedMember", "init", "EnumBooleanMember", "EnumNumberMember", "EnumStringMember", "declaration", "declar", "specifiers", "length", "printList", "source", "ExistsTypeAnnotation", "FunctionTypeAnnotation", "typeParameters", "this", "params", "rest", "type", "method", "returnType", "FunctionTypeParam", "optional", "InterfaceExtends", "_node$extends", "extends", "_node$mixins", "_node$implements", "mixins", "implements", "_variance", "_node$variance", "kind", "variance", "andSeparator", "occurrenceCount", "InterfaceTypeAnnotation", "_node$extends2", "IntersectionTypeAnnotation", "printJoin", "types", "undefined", "MixedTypeAnnotation", "EmptyTypeAnnotation", "NullableTypeAnnotation", "NumberTypeAnnotation", "StringTypeAnnotation", "ThisTypeAnnotation", "TupleTypeAnnotation", "TypeofTypeAnnotation", "argument", "right", "TypeAnnotation", "tokenContext", "TokenContext", "arrowFlowReturnType", "TypeParameterInstantiation", "TypeParameter", "bound", "supertype", "impltype", "ObjectTypeAnnotation", "exact", "props", "properties", "callProperties", "indexers", "internalSlots", "addNewlines", "leading", "inexact", "ObjectTypeInternalSlot", "static", "ObjectTypeCallProperty", "ObjectTypeIndexer", "key", "ObjectTypeProperty", "proto", "ObjectTypeSpreadProperty", "QualifiedTypeIdentifier", "qualification", "SymbolTypeAnnotation", "orSeparator", "UnionTypeAnnotation", "TypeCastExpression", "expression", "Variance", "VoidTypeAnnotation", "IndexedAccessType", "objectType", "indexType", "OptionalIndexedAccessType", "File", "node", "program", "print", "interpreter", "Program", "_node$directives", "noIndentInnerCommentsHere", "printInnerComments", "directivesLen", "directives", "length", "_node$directives$trai", "newline", "body", "printSequence", "undefined", "trailingComments", "BlockStatement", "_node$directives2", "token", "exit", "enterDelimited", "_node$directives$trai2", "rightBrace", "Directive", "value", "semicolon", "unescapedSingleQuoteRE", "unescapedDoubleQuoteRE", "DirectiveLiteral", "raw", "getPossibleRaw", "format", "minified", "test", "Error", "InterpreterDirective", "Placeholder", "name", "expectedNode", "JSXAttribute", "node", "print", "name", "value", "token", "JSXIdentifier", "word", "JSXNamespacedName", "namespace", "JSXMemberExpression", "object", "property", "JSXSpreadAttribute", "argument", "rightBrace", "JSXExpressionContainer", "expression", "JSXSpreadChild", "JSXText", "raw", "getPossibleRaw", "undefined", "JSXElement", "open", "openingElement", "selfClosing", "indent", "child", "children", "dedent", "closingElement", "spaceSeparator", "space", "JSXOpeningElement", "typeArguments", "typeParameters", "attributes", "length", "printJoin", "JSXClosingElement", "JSXEmptyExpression", "printInnerComments", "JSXFragment", "openingFragment", "closingFragment", "JSXOpeningFragment", "JSXClosingFragment", "TSTypeAnnotation", "node", "parent", "token", "type", "typeAnnotation", "space", "optional", "print", "TSTypeParameterInstantiation", "printTrailingSeparator", "params", "length", "tokenMap", "start", "end", "find", "t", "matchesOriginal", "shouldPrintTrailingComma", "printList", "TSTypeParameter", "in", "word", "out", "name", "constraint", "default", "TSParameterProperty", "accessibility", "readonly", "_param", "parameter", "TSDeclareFunction", "declare", "_functionHead", "semicolon", "TSDeclareMethod", "_classMethodHead", "TSQualifiedName", "left", "right", "TSCallSignatureDeclaration", "tsPrintSignatureDeclarationBase", "maybePrintTrailingCommaOrSemicolon", "printer", "endMatches", "TSConstructSignatureDeclaration", "TSPropertySignature", "tsPrintPropertyOrMethodName", "computed", "key", "TSMethodSignature", "kind", "TSIndexSignature", "static", "isStatic", "_parameters", "parameters", "TSAnyKeyword", "TSBigIntKeyword", "TSUnknownKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSBooleanKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSVoidKeyword", "TSUndefinedKeyword", "TSNullKeyword", "TSNeverKeyword", "TSIntrinsicKeyword", "TSThisType", "TSFunctionType", "tsPrintFunctionOrConstructorType", "TSConstructorType", "abstract", "typeParameters", "returnType", "TSTypeReference", "typeArguments", "typeName", "TSTypePredicate", "asserts", "parameterName", "TSTypeQuery", "exprName", "TSTypeLiteral", "printBraced", "printJoin", "members", "TSArrayType", "elementType", "TSTupleType", "elementTypes", "TSOptionalType", "TSRestType", "TSNamedTupleMember", "label", "TSUnionType", "tsPrintUnionOrIntersectionType", "TSIntersectionType", "sep", "_printer$tokenMap", "hasLeadingToken", "startMatches", "types", "undefined", "i", "TSConditionalType", "checkType", "extendsType", "trueType", "falseType", "TSInferType", "typeParameter", "TSParenthesizedType", "TSTypeOperator", "operator", "TSIndexedAccessType", "objectType", "indexType", "TSMappedType", "nameType", "exit", "enterDelimited", "tokenIfPlusMinus", "self", "tok", "TSLiteralType", "literal", "TSClassImplements", "expression", "TSInterfaceDeclaration", "id", "extends", "extendz", "body", "TSInterfaceBody", "TSTypeAliasDeclaration", "TSTypeExpression", "TSTypeAssertion", "TSInstantiationExpression", "TSEnumDeclaration", "const", "isConst", "TSEnumBody", "call", "_this$shouldPrintTrai", "TSEnumMember", "initializer", "TSModuleDeclaration", "global", "TSModuleBlock", "printSequence", "TSImportType", "argument", "qualifier", "options", "TSImportEqualsDeclaration", "isExport", "moduleReference", "TSExternalModuleReference", "TSNonNullExpression", "TSExportAssignment", "TSNamespaceExportDeclaration", "tsPrintClassMemberModifiers", "isField", "printModifiersList", "override", "cb", "rightBrace", "modifiers", "_printer$tokenMap2", "modifiersSet", "Set", "modifier", "add", "has", "value", "delete", "size", "_templateLiterals", "require", "Object", "keys", "forEach", "key", "exports", "defineProperty", "enumerable", "get", "_expressions", "_statements", "_classes", "_methods", "_modules", "_types", "_flow", "_base", "_jsx", "_typescript", "addDeprecatedGenerators", "PrinterClass", "deprecatedBabel7Generators", "Noop", "TSExpressionWithTypeArguments", "node", "print", "expression", "typeParameters", "DecimalLiteral", "raw", "getPossibleRaw", "format", "minified", "undefined", "word", "value", "Object", "assign", "prototype", "_buffer", "require", "n", "_t", "_tokenMap", "generatorFunctions", "_deprecated", "isExpression", "isFunction", "isStatement", "isClassBody", "isTSInterfaceBody", "isTSEnumMember", "SCIENTIFIC_NOTATION", "ZERO_DECIMAL_INTEGER", "HAS_NEWLINE", "HAS_NEWLINE_OR_BlOCK_COMMENT_END", "commentIsNewline", "c", "type", "test", "value", "needsParens", "Printer", "constructor", "format", "map", "tokens", "originalCode", "inForStatementInit", "tokenContext", "_tokens", "_originalCode", "_currentNode", "_indent", "_indentRepeat", "_insideAux", "_noLineTerminator", "_noLineTerminatorAfterNode", "_printAuxAfterOnNextUserNode", "_printedComments", "Set", "_endsWithInteger", "_endsWithWord", "_endsWithDiv", "_lastCommentLine", "_endsWithInnerRaw", "_indentInnerComments", "tokenMap", "_boundGetRawIdentifier", "_getRawIdentifier", "bind", "_printSemicolonBeforeNextNode", "_printSemicolonBeforeNextToken", "indent", "style", "length", "_inputMap", "_buf", "Buffer", "enterForStatementInit", "enterDelimited", "oldInForStatementInit", "oldNoLineTerminatorAfterNode", "generate", "ast", "preserveFormat", "TokenMap", "print", "_maybeAddAuxComment", "get", "compact", "concise", "dedent", "semicolon", "force", "_appendChar", "node", "start", "end", "endMatches", "getCurrentLine", "indexes", "getIndexes", "_catchUpTo", "loc", "_queue", "rightBrace", "minified", "removeLastSemicolon", "sourceWithOffset", "token", "rightParens", "space", "_space", "hasContent", "lastCp", "getLastChar", "word", "str", "noLineTerminatorAfter", "_maybePrintInnerComments", "_catchUpToCurrentToken", "charCodeAt", "_append", "number", "isNonDecimalLiteral", "secondChar", "Number", "isInteger", "maybeNewline", "occurrenceCount", "lastChar", "strFirst", "tokenChar", "char", "String", "fromCharCode", "newline", "i", "retainLines", "getNewlineCount", "j", "_newline", "endsWith", "endsWithCharAndNewline", "removeTrailingNewline", "exactSource", "cb", "_catchUp", "source", "prop", "columnOffset", "sourceIdentifierName", "identifierName", "pos", "_canMarkIdName", "sourcePosition", "_sourcePosition", "identifierNamePos", "findMatching", "appendChar", "_maybeIndent", "append", "queue", "firstChar", "queueIndentation", "_getIndent", "_shouldIndent", "catchUp", "line", "count", "column", "index", "spacesCount", "getCurrentColumn", "spaces", "slice", "replace", "repeat", "printTerminatorless", "trailingCommentsLineOffset", "_node$extra", "_node$leadingComments", "_node$leadingComments2", "nodeType", "oldConcise", "_compact", "printMethod", "undefined", "ReferenceError", "JSON", "stringify", "name", "parent", "oldInAux", "parenthesized", "extra", "shouldPrintParens", "retainFunctionParens", "leadingComments", "parentType", "callee", "indentParenthesized", "some", "oldInForStatementInitWasTrue", "isLastChild", "_node$trailingComment", "trailingComments", "_printLeadingComments", "_printTrailingComments", "enteredPositionlessNode", "_printAuxBeforeComment", "_printAuxAfterComment", "comment", "auxiliaryCommentBefore", "_printComment", "auxiliaryCommentAfter", "getPossibleRaw", "raw", "rawValue", "printJoin", "nodes", "statement", "separator", "printTrailingSeparator", "addNewlines", "iterator", "_nodes$0$loc", "startLine", "newlineOpts", "nextNodeStartLine", "boundSeparator", "len", "_printNewline", "_node$trailingComment2", "_nextNode$loc", "nextNode", "printAndIndentOnComments", "printBlock", "body", "lineOffset", "innerComments", "_printComments", "comments", "nextTokenStr", "nextTokenOccurrenceCount", "_this$tokenMap", "printInnerComments", "nextToken", "hasSpace", "printedCommentsCount", "size", "noIndentInnerCommentsHere", "printSequence", "printList", "items", "commaSeparator", "shouldPrintTrailingComma", "listEnd", "listEndIndex", "findLastIndex", "matchesOriginal", "newLine", "opts", "lastCommentLine", "offset", "_shouldPrintComment", "ignore", "has", "commentTok", "find", "add", "shouldPrintComment", "skipNewLines", "noLineTerminator", "isBlockComment", "printNewLines", "lastCharCode", "val", "adjustMultilineComment", "_comment$loc", "newlineRegex", "RegExp", "indentSize", "nodeLoc", "hasLoc", "nodeStartLine", "nodeEndLine", "lastLine", "leadingCommentNewline", "shouldPrint", "commentStartLine", "commentEndLine", "Math", "max", "min", "singleLine", "shouldSkipNewline", "properties", "Object", "assign", "prototype", "addDeprecatedGenerators", "_default", "exports", "default", "last", "_sourceMap", "require", "_printer", "normalizeOptions", "code", "opts", "ast", "experimental_preserveFormat", "Error", "retainLines", "compact", "minified", "jsescOption", "Array", "isArray", "tokens", "format", "auxiliaryCommentBefore", "auxiliaryCommentAfter", "shouldPrintComment", "preserveFormat", "retainFunctionParens", "comments", "concise", "indent", "adjustMultilineComment", "style", "Object", "assign", "quotes", "wrap", "minimal", "topicToken", "importAttributesKeyword", "_opts$recordAndTupleS", "decoratorsBeforeExport", "json", "jsonCompatibleStrings", "recordAndTupleSyntaxType", "value", "includes", "length", "console", "error", "filename", "undefined", "exports", "CodeGenerator", "constructor", "_ast", "_format", "_map", "sourceMaps", "SourceMap", "generate", "printer", "Printer", "map"]
}
